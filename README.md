### Конфигурация:
1. `app.json`, можно изменить в web-интерфейсе:
    1. `default_limit` {float}: лимит для периодов по умолчанию.
    2. `adaptive_limit` {bool}: переключатель режимов работы при превышении лимита. `True` для адаптивного, `False` для ручного.
2. `flask-config.py`:
    1. `WTF_CSRF_ENABLED` {bool}: Активация CSRF для форм.
    2. `SQLALCHEMY_DATABASE_URI` {string}: Путь до базы данных.
### Деплой:
1. При необходимости разворачиваем virtualenv.
2. Устанавливаем зависимости:
`pip install -r requirements.txt`

    Безусловно для описания зависимостей можно было использовать pipfile, однако в ТЗ был выбран requirements.txt.
3. Запускаем сервер:

    **dev**-вариант - `flask run`;

    **production**-вариант - `gunicorn app`.
4. При необходимости для очистки базы данных можно использовать `./update_db.py clear`.

### Пояснительная записка:
Считаю необходимым кроме прочего написать по каким причинам некоторые компоненты были реализованы именно так.
1. База данных в репозитории слегка заполнена данными для наглядности. При желании ее можно очистить.
2. Таблица custom_periods не имеет явной связи с таблицей spending т.к. содержит в себе только отдельные периоды из-за чего "безопасная" связь не представляется возможным, а иная на мой взгляд тут не совсем нужна.

    Сделано это было для уменьшения нагрузки на бд в плане объемов информации.
3. Для конфигурационного файла "бизнес-логики" был выбран формат json т.к. он позволяет куда проще (в сравнении с python-модулем) сохранять изменения на диск и имеет довольно "легкую" структуру.
4. При изменений лимита по умолчанию из веб-интерфейса не производится обработка согласно методики работы с "превышениями" т.к. это добавило бы дополнительную логику на старте приложения (при чтении конфига) и могло бы привести к неплохому снежному кому, которому пришлось бы выделить отдельный поток учитывая возможные размеры базы.
5. Добавлена возможность изменять лимиты конкретных периодов т.к. структура приложения по сути и так поддерживала данный функционал + это вероятно удобно.
6. На фронтенде использовался только бутстрап т.к. моя задача в первую очередь в написании бэкэнда. Безусловно можно было написать какой-то серьезный фронтенд с масками инпутов, spa-архитектурой, транспилингом и т.д., однако у меня нет такого количества времени на тестовые задания и в самом ТЗ как плюс описывалась работа с Jinja2.
7. На главную страницу можно было добавить пагинацию т.к. этот список будет уже достаточно большим через пару лет теоретического использования, однако не думаю что это критично для тестового задания.
8. К сожалению нет времени на полное документирование проекта, соответственно этот пункт выполнен не будет.
9. Пока мало работал с юнитами в контексте веб-бэкэнда, соответственно этот пункт выполнен не будет.
10. При добавлении расходов можно ввести дату из будущего, не стал запрещать это т.к. данное поведение как минимум ничем не мешает при тестировании логики, а местами может и помочь.
11. Не стал добавлять миграции т.к. как оказалось пакет sqlalchemy-migration морально устарел, да и бд не такая большая и сложная.
12. Какая-либо обертка для деплоя отсутствует по причине отсутствия продакшна/демо. Однако в зависимости добавлен gunicorn.
